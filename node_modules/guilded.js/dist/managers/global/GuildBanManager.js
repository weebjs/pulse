"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalGuildBanManager = void 0;
const collection_1 = require("@discordjs/collection");
const Member_1 = require("../../structures/Member");
const CacheableStructManager_1 = require("./CacheableStructManager");
const util_1 = require("../../util");
/**
 * Manages guild bans in all servers.
 */
class GlobalGuildBanManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Returns whether bans should be cached.
     */
    get shouldCacheBan() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMemberBans) !== false;
    }
    /**
     * Fetches a member ban in a server.
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @param force Whether to force fetch the ban even if it's cached.
     * @returns A Promise that resolves with the fetched member ban.
     */
    fetch(serverId, userId, force) {
        if (!force) {
            const existingMemberBan = this.client.bans.cache.get((0, util_1.buildMemberKey)(serverId, userId));
            if (existingMemberBan)
                return Promise.resolve(existingMemberBan);
        }
        return this.client.rest.router.getMemberBan(serverId, userId).then((data) => {
            const newMemberBan = new Member_1.MemberBan(this.client, Object.assign(Object.assign({}, data.serverMemberBan), { serverId }));
            if (this.shouldCacheBan)
                this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            return newMemberBan;
        });
    }
    /**
     * Fetches all bans in a server.
     * @param serverId The ID of the server.
     * @returns A Promise that resolves with a collection of the fetched member bans.
     */
    fetchMany(serverId) {
        return this.client.rest.router.getMemberBans(serverId).then((data) => {
            const newMemberBans = new collection_1.Collection();
            for (const ban of data.serverMemberBans) {
                const newMemberBan = new Member_1.MemberBan(this.client, Object.assign({ serverId }, ban));
                newMemberBans.set(newMemberBan.id, newMemberBan);
                if (this.shouldCacheBan)
                    this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            }
            return newMemberBans;
        });
    }
    /**
     * Bans a user from a server.
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @returns A Promise that resolves with the newly created member ban.
     */
    ban(serverId, userId) {
        return this.client.rest.router.banMember(serverId, userId).then((data) => {
            const newMemberBan = new Member_1.MemberBan(this.client, Object.assign({ serverId }, data.serverMemberBan));
            if (this.shouldCacheBan)
                this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            return newMemberBan;
        });
    }
    /**
     * Unbans a user from a server.
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @param removeBanIfCached Whether to remove the ban from the cache if it exists.
     * @returns A Promise that resolves with the unbanned member ban or `null` if it isn't cached.
     */
    unban(serverId, userId, removeBanIfCached = false) {
        return this.client.rest.router.unbanMember(serverId, userId).then((data) => {
            var _a;
            const memberKey = (0, util_1.buildMemberKey)(serverId, userId);
            const existingBan = this.client.bans.cache.get(memberKey);
            if (((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.removeMemberBanOnUnban) || removeBanIfCached)
                this.client.bans.cache.delete(memberKey);
            return existingBan !== null && existingBan !== void 0 ? existingBan : null;
        });
    }
}
exports.GlobalGuildBanManager = GlobalGuildBanManager;
//# sourceMappingURL=GuildBanManager.js.map