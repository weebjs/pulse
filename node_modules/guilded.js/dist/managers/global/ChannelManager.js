"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeToChannel = exports.transformTypeToChannel = exports.GlobalChannelManager = void 0;
const structures_1 = require("../../structures");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * Manages channels on the global scope. This can hold channels of any type, with all of them extending Channel.
 * You will likely need to cast the returned values from cache or fetches
 * @extends CacheableStructManager
 */
class GlobalChannelManager extends CacheableStructManager_1.CacheableStructManager {
    /** Determine whether a channel should be cached or not */
    get shouldCacheChannel() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheChannels) !== false;
    }
    /**
     * Create a new channel
     * @param options Channel creation options
     * @returns Promise that resolves with the newly created channel
     */
    create(options) {
        return this.client.rest.router.createChannel(options).then((data) => {
            const newChannel = new ((0, exports.transformTypeToChannel)(data.channel.type))(this.client, data.channel);
            return newChannel;
        });
    }
    /**
     * Fetch a channel by ID
     * Notice: if you're using TypeScript, you will need to upcast to your desired channel type.
     * @param channelId ID of the channel to fetch
     * @param force Whether to force a fetch from the API
     * @returns Promise that resolves with the fetched channel
     */
    fetch(channelId, force) {
        if (!force) {
            const existingChannel = this.client.channels.cache.get(channelId);
            if (existingChannel)
                return Promise.resolve(existingChannel);
        }
        return this.client.rest.router.getChannel(channelId).then((data) => {
            const fetchedChannel = new ((0, exports.transformTypeToChannel)(data.channel.type))(this.client, data.channel);
            if (this.shouldCacheChannel)
                this.cache.set(fetchedChannel.id, fetchedChannel);
            return fetchedChannel;
        });
    }
    /**
     * Update a channel by ID
     * @param channelId ID of the channel to update
     * @param options Channel update options
     * @returns Promise that resolves with the updated channel
     */
    update(channelId, options) {
        return this.client.rest.router
            .updateChannel(channelId, options)
            .then((data) => {
            const existingChannel = this.cache.get(channelId);
            if (existingChannel)
                return existingChannel._update(data.channel);
            const newChannel = new ((0, exports.transformTypeToChannel)(data.channel.type))(this.client, data.channel);
            if (this.shouldCacheChannel)
                this.cache.set(newChannel.id, newChannel);
            return newChannel;
        });
    }
    /**
     * Delete a channel by ID
     * @param channelId ID of the channel to delete
     * @returns Promise that resolves with the deleted channel, or void if not cached.
     */
    delete(channelId) {
        return this.client.rest.router.deleteChannel(channelId).then((data) => {
            const cachedChannel = this.cache.get(channelId);
            return cachedChannel !== null && cachedChannel !== void 0 ? cachedChannel : void 0;
        });
    }
}
exports.GlobalChannelManager = GlobalChannelManager;
/**
 * Transforms the string APIChannelType to its corresponding channel class
 * @param str String representing the channel type
 * @returns Channel class for the given channel type
 */
const transformTypeToChannel = (str) => { var _a; return (_a = exports.typeToChannel[str]) !== null && _a !== void 0 ? _a : structures_1.Channel; };
exports.transformTypeToChannel = transformTypeToChannel;
/** Mapping between the string APIChannelType and the corresponding channel class */
exports.typeToChannel = {
    forums: structures_1.ForumChannel,
    docs: structures_1.DocChannel,
    list: structures_1.ListChannel,
};
//# sourceMappingURL=ChannelManager.js.map