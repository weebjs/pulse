"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const rest_1 = require("@guildedjs/rest");
const ws_1 = require("@guildedjs/ws");
const node_events_1 = require("node:events");
const ClientGatewayHandler_1 = require("../gateway/ClientGatewayHandler");
const ChannelManager_1 = require("../managers/global/ChannelManager");
const DocManager_1 = require("../managers/global/DocManager");
const ForumManager_1 = require("../managers/global/ForumManager");
const GroupManager_1 = require("../managers/global/GroupManager");
const ListManager_1 = require("../managers/global/ListManager");
const MemberManager_1 = require("../managers/global/MemberManager");
const MessageManager_1 = require("../managers/global/MessageManager");
const RoleManager_1 = require("../managers/global/RoleManager");
const UserManager_1 = require("../managers/global/UserManager");
const GuildBanManager_1 = require("../managers/global/GuildBanManager");
const CalendarManager_1 = require("../managers/global/CalendarManager");
const WebhookManager_1 = require("../managers/global/WebhookManager");
const User_1 = require("./User");
const ServerManager_1 = require("../managers/global/ServerManager");
const ReactionManager_1 = require("../managers/global/ReactionManager");
/**
 * The main class for interacting with the api.
 * @template ClientEvents The custom events for the client.
 */
class Client extends node_events_1.EventEmitter {
    /**
     * @param options The options for the client.
     * @throws {Error} Must provide options in client constructor in the form of an object.
     * @throws {Error} No token provided.
     */
    constructor(options) {
        if (typeof options !== "object")
            throw new Error("Must provide options in client constructor in the form of an object.");
        if (typeof (options === null || options === void 0 ? void 0 : options.token) === "undefined")
            throw new Error("No token provided.");
        super();
        this.options = options;
        /**
         * The time in milliseconds since the Client connected.
         */
        this.readyTimestamp = null;
        /**
         * The manager for the bot to make requests to the REST api.
         */
        this.rest = new rest_1.RestManager(Object.assign(Object.assign({}, this.options.rest), { token: this.options.token }));
        /**
         * The websocket connection.
         */
        this.ws = new ws_1.WebSocketManager({ token: this.options.token });
        /**
         * The gateway events will be processed by this manager.
         */
        this.gatewayHandler = new ClientGatewayHandler_1.ClientGatewayHandler(this);
        /**
         * A manager for channels, used to manage and interact with channels.
         */
        this.channels = new ChannelManager_1.GlobalChannelManager(this);
        /**
         * A manager for docs, used to manage and interact with docs.
         */
        this.docs = new DocManager_1.GlobalDocManager(this);
        /**
         * A manager for forum topics, used to manage and interact with forum topics.
         */
        this.topics = new ForumManager_1.GlobalForumTopicManager(this);
        /**
         * A manager for groups, used to manage and interact with groups.
         */
        this.groups = new GroupManager_1.GlobalGroupManager(this);
        /**
         * A manager for list items, used to manage and interact with list items.
         */
        this.lists = new ListManager_1.GlobalListItemManager(this);
        /**
         * A manager for members, used to manage and interact with members.
         */
        this.members = new MemberManager_1.GlobalMemberManager(this);
        /**
         * A manager for messages, used to manage and interact with messages.
         */
        this.messages = new MessageManager_1.GlobalMessageManager(this);
        /**
         * A manager for roles, used to manage and interact with roles.
         */
        this.roles = new RoleManager_1.GlobalRoleManager(this);
        /**
         * A manager for users, used to manage and interact with users.
         */
        this.users = new UserManager_1.GlobalUserManager(this);
        /**
         * A manager for guild bans, used to manage and interact with bans.
         */
        this.bans = new GuildBanManager_1.GlobalGuildBanManager(this);
        /**
         * A manager for webhooks, used to manage and interact with webhooks.
         */
        this.webhooks = new WebhookManager_1.GlobalWebhookManager(this);
        /**
         * A manager for servers, used to manage and interact with servers.
         */
        this.servers = new ServerManager_1.GlobalServerManager(this);
        /**
         * A manager for reactions, used to manage and interact with reactions.
         */
        this.reactions = new ReactionManager_1.GlobalReactionManager(this);
        /**
         * A manager for calendars, used to manage and interact with calendars.
         */
        this.calendars = new CalendarManager_1.GlobalCalendarManager(this);
        /**
         * The user belonging to this bot.
         */
        this.user = null;
    }
    /**
     * The amount of time the bot has been online in milliseconds.
     */
    get uptime() {
        return this.readyTimestamp ? Date.now() - this.readyTimestamp : 0;
    }
    /**
     * The bot's token.
     */
    get token() {
        return this.options.token;
    }
    /**
     * Connects the bot to the api.
     * @param [opts] The options for connecting to the api.
     */
    login(opts) {
        if (opts === null || opts === void 0 ? void 0 : opts.fresh)
            this.ws = new ws_1.WebSocketManager({ token: this.options.token });
        this.ws.emitter
            .on("error", (reason, err) => this.emit("error", `[WS] ${reason}`, err))
            .on("ready", (user) => {
            this.user = new User_1.ClientUser(this, user);
            this.readyTimestamp = Date.now();
            this.emit("ready");
        })
            .on("gatewayEvent", (event, data) => this.gatewayHandler.handleWSMessage(event, data))
            .on("debug", (data) => this.emit("debug", data))
            .on("exit", () => this.emit("exit"));
        this.ws.connect();
    }
    /**
     * Disconnects the bot.
     * @throws {Error} There is no active connection to disconnect.
     */
    disconnect() {
        if (!this.ws.isAlive)
            throw new Error("There is no active connection to disconnect.");
        this.ws.emitter.removeAllListeners();
        this.ws.destroy();
        this.emit("exit");
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map