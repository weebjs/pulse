"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMessage = exports.parseToMessage = exports.transformEmbedToAPIEmbed = void 0;
const WebhookEmbed_1 = require("../webhook/WebhookEmbed");
const transformEmbedToAPIEmbed = (embeds) => embeds.map((x) => (x instanceof WebhookEmbed_1.WebhookEmbed ? x.toJSON() : x));
exports.transformEmbedToAPIEmbed = transformEmbedToAPIEmbed;
function parseToMessage(input = "", embed) {
    return {
        document: {
            data: {},
            nodes: [
                {
                    data: {},
                    nodes: [
                        {
                            leaves: [
                                {
                                    marks: [],
                                    object: "leaf",
                                    text: typeof input === "string" ? input : "",
                                },
                            ],
                            object: "text",
                        },
                    ],
                    object: "block",
                    type: "markdown-plain-text",
                },
                {
                    data: {
                        embeds: embed ? (embed instanceof WebhookEmbed_1.WebhookEmbed ? [embed === null || embed === void 0 ? void 0 : embed.toJSON()] : [embed]) : typeof input === "string" ? [] : input instanceof WebhookEmbed_1.WebhookEmbed ? [input === null || input === void 0 ? void 0 : input.toJSON()] : [input],
                    },
                    nodes: [],
                    object: "block",
                    type: "webhookMessage",
                },
            ],
            object: "document",
        },
        object: "value",
    };
}
exports.parseToMessage = parseToMessage;
/**
 * Parse a message recieved from Guilded into a more digestable structure
 *
 * @internal
 */
function parseMessage(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
    const parsedMessageArray = [];
    let parsedMessageTextContent = "";
    const mentions = {
        channels: [],
        reactions: [],
        roles: [],
        users: [],
    };
    const embeds = [];
    const messageLinesWithoutEmpty = data.document.nodes.filter((x) => x.type === "webhookMessage"
        ? x.data.embeds.length > 0
        : true);
    for (let index = 0; index < messageLinesWithoutEmpty.length; index++) {
        const messageLine = data.document.nodes[index];
        if (index)
            parsedMessageTextContent += "\n";
        switch (messageLine.type) {
            case "paragraph": {
                for (const node of messageLine.nodes) {
                    switch (node.object) {
                        case "text": {
                            for (const leaf of node.leaves) {
                                if (leaf.text) {
                                    parsedMessageArray.push({
                                        content: leaf.text,
                                        type: "text",
                                    });
                                }
                                parsedMessageTextContent += leaf.text;
                            }
                            break;
                        }
                        case "inline": {
                            const castedDataNode = node.data;
                            const leaf = (_b = (_a = node.nodes) === null || _a === void 0 ? void 0 : _a[0].leaves) === null || _b === void 0 ? void 0 : _b[0];
                            if (!leaf)
                                break;
                            switch (node.type) {
                                case "mention": {
                                    switch ((_c = castedDataNode.mention) === null || _c === void 0 ? void 0 : _c.type) {
                                        case "person": {
                                            mentions.users.push((_d = castedDataNode.mention) === null || _d === void 0 ? void 0 : _d.id);
                                            parsedMessageArray.push({
                                                content: leaf.text,
                                                mention: castedDataNode.mention,
                                                type: "user",
                                            });
                                            break;
                                        }
                                        case "role": {
                                            parsedMessageArray.push({
                                                content: leaf.text,
                                                mention: castedDataNode.mention,
                                                type: "role",
                                            });
                                            mentions.roles.push((_e = castedDataNode.mention) === null || _e === void 0 ? void 0 : _e.id.toString());
                                            break;
                                        }
                                    }
                                    break;
                                }
                                /* istanbul ignore next */
                                case "reaction": {
                                    mentions.reactions.push((_f = castedDataNode.reaction) === null || _f === void 0 ? void 0 : _f.id);
                                    parsedMessageArray.push({
                                        content: leaf.text,
                                        reaction: castedDataNode.reaction,
                                        type: "reaction",
                                    });
                                    break;
                                }
                                case "channel": {
                                    mentions.channels.push((_g = castedDataNode.channel) === null || _g === void 0 ? void 0 : _g.id);
                                    parsedMessageArray.push({
                                        channel: castedDataNode.channel,
                                        content: leaf.text,
                                        type: "channel",
                                    });
                                    break;
                                }
                            }
                            parsedMessageTextContent += leaf.text;
                            break;
                        }
                    }
                }
                break;
            }
            /* istanbul ignore next */
            case "block-quote-container": {
                for (const messageNodes of messageLine.nodes) {
                    for (const node of messageNodes.nodes) {
                        switch (node.object) {
                            case "text": {
                                if ((_h = node.leaves) === null || _h === void 0 ? void 0 : _h[0].text) {
                                    parsedMessageArray.push({
                                        content: (_j = node.leaves) === null || _j === void 0 ? void 0 : _j[0].text,
                                        type: "text",
                                    });
                                }
                                parsedMessageTextContent += (_k = node.leaves) === null || _k === void 0 ? void 0 : _k[0].text;
                                break;
                            }
                            case "inline": {
                                const castedDataNode = node.data;
                                switch (node.type) {
                                    case "mention": {
                                        switch ((_l = castedDataNode.mention) === null || _l === void 0 ? void 0 : _l.type) {
                                            case "person": {
                                                mentions.users.push((_m = castedDataNode.mention) === null || _m === void 0 ? void 0 : _m.id);
                                                parsedMessageArray.push({
                                                    content: (_p = (_o = node.nodes) === null || _o === void 0 ? void 0 : _o[0].leaves) === null || _p === void 0 ? void 0 : _p[0].text,
                                                    mention: castedDataNode.mention,
                                                    type: "user",
                                                });
                                                break;
                                            }
                                            case "role": {
                                                parsedMessageArray.push({
                                                    content: (_r = (_q = node.nodes) === null || _q === void 0 ? void 0 : _q[0].leaves) === null || _r === void 0 ? void 0 : _r[0].text,
                                                    mention: castedDataNode.mention,
                                                    type: "role",
                                                });
                                                mentions.roles.push((_s = castedDataNode.mention) === null || _s === void 0 ? void 0 : _s.id.toString());
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                    case "reaction": {
                                        mentions.reactions.push((_t = castedDataNode.reaction) === null || _t === void 0 ? void 0 : _t.id);
                                        parsedMessageArray.push({
                                            content: (_v = (_u = node.nodes) === null || _u === void 0 ? void 0 : _u[0].leaves) === null || _v === void 0 ? void 0 : _v[0].text,
                                            reaction: castedDataNode.reaction,
                                            type: "reaction",
                                        });
                                        break;
                                    }
                                    case "channel": {
                                        mentions.channels.push((_w = castedDataNode.channel) === null || _w === void 0 ? void 0 : _w.id);
                                        parsedMessageArray.push({
                                            channel: castedDataNode.channel,
                                            content: (_y = (_x = node.nodes) === null || _x === void 0 ? void 0 : _x[0].leaves) === null || _y === void 0 ? void 0 : _y[0].text,
                                            type: "channel",
                                        });
                                        break;
                                    }
                                }
                                parsedMessageTextContent += (_0 = (_z = node.nodes) === null || _z === void 0 ? void 0 : _z[0].leaves) === null || _0 === void 0 ? void 0 : _0[0].text;
                                break;
                            }
                        }
                    }
                }
                break;
            }
            case "markdown-plain-text": {
                if ((_2 = (_1 = messageLine.nodes) === null || _1 === void 0 ? void 0 : _1[0].leaves) === null || _2 === void 0 ? void 0 : _2[0].text) {
                    parsedMessageArray.push({
                        content: (_4 = (_3 = messageLine.nodes) === null || _3 === void 0 ? void 0 : _3[0].leaves) === null || _4 === void 0 ? void 0 : _4[0].text,
                        type: "text",
                    });
                }
                parsedMessageTextContent += (_6 = (_5 = messageLine.nodes) === null || _5 === void 0 ? void 0 : _5[0].leaves) === null || _6 === void 0 ? void 0 : _6[0].text;
                break;
            }
            case "webhookMessage": {
                embeds.push(...messageLine.data.embeds);
                break;
            }
        }
    }
    return {
        embeds,
        mentions,
        parsedArr: parsedMessageArray,
        parsedText: parsedMessageTextContent.trim(),
    };
}
exports.parseMessage = parseMessage;
//# sourceMappingURL=message.js.map