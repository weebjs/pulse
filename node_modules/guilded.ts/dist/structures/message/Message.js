"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageType = exports.Message = void 0;
const guilded_api_typings_1 = require("guilded-api-typings");
Object.defineProperty(exports, "MessageType", { enumerable: true, get: function () { return guilded_api_typings_1.MessageType; } });
const Base_1 = require("../Base");
const MessageReactionManager_1 = require("../../managers/message/MessageReactionManager");
const MessageReactionCollector_1 = require("../../collectors/MessageReactionCollector");
const collection_1 = require("@discordjs/collection");
/**
 * Represents a message on Guilded.
 * @example new Message(channel, rawMessage);
 */
class Message extends Base_1.Base {
    channel;
    raw;
    /** The type of the message. */
    type;
    /** The ID of the server the message belongs to. */
    serverId;
    /** The ID of the channel the message belongs to. */
    channelId;
    /** The content of the message. */
    content;
    /** The embeds in the message. */
    embeds;
    /** The IDs of messages that were replied to. */
    replyMessageIds;
    /** Whether the message is private. */
    isPrivate;
    /** Whether the message is silent. */
    isSilent;
    /** The mentions of the message. */
    mentions;
    /** The date the message was created. */
    createdAt;
    /** The ID of the user that created the message. */
    createdBy;
    /** The ID of the webhook that created the message. */
    createdByWebhookId;
    /** The date the message was edited. */
    editedAt;
    /** The date the message was deleted. */
    deletedAt;
    /** A manager of reactions that belong to the message. */
    reactions;
    /**
     * @param channel The chat channel the message belongs to.
     * @param raw The raw data of the message.
     * @param cache Whether to cache the message.
     */
    constructor(channel, raw, cache = channel.client.options.cacheMessages ?? true) {
        super(channel.client, raw.id);
        this.channel = channel;
        this.raw = raw;
        this.reactions = new MessageReactionManager_1.MessageReactionManager(this);
        this.type = raw.type;
        this.serverId = raw.serverId;
        this.channelId = raw.channelId;
        this.content = raw.content;
        this.embeds = raw.embeds || [];
        this.replyMessageIds = raw.replyMessageIds || [];
        this.isPrivate = raw.isPrivate;
        this.isSilent = raw.isSilent;
        this.mentions = raw.mentions;
        this.createdAt = new Date(raw.createdAt);
        this.createdBy = raw.createdBy;
        this.createdByWebhookId = raw.createdByWebhookId;
        this.editedAt = raw.updatedAt ? new Date(raw.updatedAt) : undefined;
        if (cache)
            channel.messages.cache.set(this.id, this);
    }
    /** Whether the message is cached. */
    get isCached() {
        return this.channel.messages.cache.has(this.id);
    }
    /** Whether the message is a default message. */
    get isDefault() {
        return this.type === guilded_api_typings_1.MessageType.Default;
    }
    /** Whether the message is a system message. */
    get isSystem() {
        return this.type === guilded_api_typings_1.MessageType.System;
    }
    /** The server the message belongs to. */
    get server() {
        return this.channel.server;
    }
    /** The group the message belongs to. */
    get group() {
        return this.channel.group;
    }
    /** The timestamp the message was created. */
    get createdTimestamp() {
        return this.createdAt.getTime();
    }
    /** The timestamp the message was edited. */
    get editedTimestamp() {
        return this.editedAt?.getTime();
    }
    /** Whether the message is deleted. */
    get isDeleted() {
        return !!this.deletedAt;
    }
    /** The server member that created the message. */
    get author() {
        return this.server?.members.cache.get(this.createdBy);
    }
    /** The webhook that created the message. */
    get webhook() {
        return this.createdByWebhookId
            ? this.channel.webhooks.cache.get(this.createdByWebhookId)
            : undefined;
    }
    /** The ID of the user that created the message. */
    get authorId() {
        return this.createdByWebhookId || this.createdBy;
    }
    /** The messages that were replied to. */
    get replies() {
        const messages = new collection_1.Collection();
        for (const id of this.replyMessageIds) {
            const message = this.channel.messages.cache.get(id);
            if (message)
                messages.set(id, message);
        }
        return messages;
    }
    /** The timestamp the message was deleted. */
    get deletedTimestamp() {
        return this.deletedAt?.getTime();
    }
    /** Whether the message is editable. */
    get isEditable() {
        return this.createdBy === this.client.user?.id;
    }
    /**
     * Fetch the message.
     * @param options The options to fetch the message with.
     * @returns The fetched message.
     * @example message.fetch();
     */
    fetch(options) {
        return this.channel.messages.fetch(this, options);
    }
    /**
     * Fetch the server the message belongs to.
     * @param options The options to fetch the server with.
     * @returns The fetched server.
     * @example message.fetchServer();
     */
    fetchServer(options) {
        return this.channel.fetchServer(options);
    }
    /**
     * Fetch the group the message belongs to.
     * @param options The options to fetch the group with.
     * @returns The fetched group.
     * @example message.fetchGroup();
     */
    fetchGroup(options) {
        return this.channel.fetchGroup(options);
    }
    /**
     * Fetch the server member that created the message.
     * @param options The options to fetch the server member with.
     * @returns The fetched server member.
     * @example message.fetchAuthor();
     */
    async fetchAuthor(options) {
        const server = await this.fetchServer();
        return server.members.fetch(this.createdBy, options);
    }
    /**
     * Fetch the webhook that created the message.
     * @param options The options to fetch the webhook with.
     * @returns The fetched webhook.
     * @example message.fetchWebhook();
     */
    fetchWebhook(options) {
        return this.createdByWebhookId
            ? this.channel.webhooks.fetch(this.createdByWebhookId, options)
            : undefined;
    }
    /**
     * Fetch the messages that were replied to.
     * @param options The options to fetch the messages with.
     * @returns The fetched messages.
     */
    async fetchReplies(options) {
        const messages = new collection_1.Collection();
        for (const id of this.replyMessageIds) {
            const message = await this.channel.messages.fetch(id, { cache: options?.cache });
            messages.set(id, message);
        }
        return messages;
    }
    /**
     * Edit the message.
     * @param payload The payload of the message.
     * @returns The edited message.
     * @example message.edit('Hello World!');
     */
    edit(payload) {
        return this.channel.messages.edit(this, payload);
    }
    /**
     * Delete the message.
     * @returns The deleted message.
     * @example message.delete();
     */
    async delete() {
        await this.channel.messages.delete(this);
        return this;
    }
    /**
     * Reply to the message.
     * @param payload The payload of the message.
     * @returns The created message.
     * @example message.reply('Hello World!');
     */
    reply(payload) {
        payload =
            typeof payload === 'string'
                ? { content: payload }
                : Array.isArray(payload)
                    ? { embeds: payload }
                    : payload;
        if (typeof payload === 'object')
            payload.replyMessageIds = [
                ...(payload.replyMessageIds ?? []),
                ...this.replyMessageIds,
                this.id,
            ];
        return this.channel.messages.create(payload);
    }
    /**
     * React to the message.
     * @param emojiId The ID of the emoji to react with.
     * @returns The message.
     * @example message.react(123);
     */
    async react(emojiId) {
        await this.reactions.add(emojiId);
        return this;
    }
    /**
     * Create a reaction collector for the message.
     * @params options The options of the reaction collector.
     * @returns The created reaction collector.
     * @example message.createReactionCollector();
     */
    createReactionCollector(options) {
        return new MessageReactionCollector_1.MessageReactionCollector(this, options);
    }
    /**
     * Similar to createReactionCollector but in promise form.
     * @param options The options of the reaction collector.
     * @returns The collected reactions.
     * @example message.awaitReactions();
     */
    awaitReactions(options) {
        return new Promise((resolve) => this.createReactionCollector(options).once('end', resolve));
    }
}
exports.Message = Message;
//# sourceMappingURL=Message.js.map