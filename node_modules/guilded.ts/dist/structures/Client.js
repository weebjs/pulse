"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const events_1 = __importDefault(require("events"));
const rest_1 = __importDefault(require("@guildedts/rest"));
const ws_1 = __importDefault(require("@guildedts/ws"));
const User_1 = require("./User");
const ChannelManager_1 = require("../managers/channel/ChannelManager");
const GroupManager_1 = require("../managers/group/GroupManager");
const ServerManager_1 = require("../managers/server/ServerManager");
const UserManager_1 = require("../managers/UserManager");
const ws_2 = require("../ws");
/**
 * The main hub for interacting with the Guilded API.
 * @example
 * const client = new Client();
 * client.once('ready', () => console.log(`Logged in as ${client.user!.name}!`));
 * client.login('token');
 */
class Client extends events_1.default {
    options;
    /** The REST manager for the Guilded API. */
    rest;
    /** The Websocket manager for the Guilded API. */
    ws;
    /** The manager of channels that belong to the client. */
    channels;
    /** The manager of users that belong to the client. */
    users;
    /** The manager of servers that belong to the client. */
    servers;
    /** The manager of groups that belong to the client. */
    groups;
    /** The auth token for the Guilded API. */
    token;
    /** The user the client is logged in as. */
    user;
    /** @param options The options for the client. */
    constructor(options = {}) {
        super();
        this.options = options;
        this.token = options.token;
        this.rest = new rest_1.default({
            token: this.token,
            version: 1,
            maxRetries: options.maxRestAPIRetries,
            retryInterval: options.restAPIRetryInterval,
        });
        this.ws = new ws_1.default({
            token: options.token,
            version: 1,
            reconnect: options.reconnect,
            maxReconnects: options.maxReconnects,
        });
        this.channels = new ChannelManager_1.ChannelManager(this);
        this.users = new UserManager_1.UserManager(this);
        this.servers = new ServerManager_1.ServerManager(this);
        this.groups = new GroupManager_1.GroupManager(this);
        this.ws.on('ready', this.onWSConnect.bind(this));
        this.ws.on('reconnect', this.onWSReconnect.bind(this));
        this.ws.on('disconnect', this.onWSDisconnect.bind(this));
        this.ws.on('event', this.onWSEvent.bind(this));
    }
    /** The router for the Guilded REST API. */
    get api() {
        return this.rest.router;
    }
    /** Whether the client is ready to use. */
    get isReady() {
        return this.ws.isReady;
    }
    /** The date the client was ready. */
    get readyAt() {
        return this.ws.readyAt;
    }
    /** The timestamp the client was ready. */
    get readyTimestamp() {
        return this.ws.readyTimestamp;
    }
    /** The time the client has been in the ready state. */
    get uptime() {
        return this.ws.uptime;
    }
    /**
     * Login to the Guilded API.
     * @param token The auth token for the Guilded API.
     * @returns The client.
     * @example client.login('token');
     */
    login(token) {
        this.token = token || this.token;
        this.rest.setToken(this.token);
        this.ws.connect(this.token);
        return new Promise((resolve) => this.once('ready', () => resolve(this)));
    }
    /**
     * Disconnect from Guilded.
     * @returns The client.
     * @example client.disconnect();
     */
    disconnect() {
        this.ws.disconnect();
        return this;
    }
    /**
     * Debug the client.
     * @param data The debug data.
     * @returns The client.
     * @example client.debug('Hello World!');
     */
    debug(data) {
        this.emit('debug', this, data);
        return this;
    }
    /** @ignore */
    onWSConnect(user) {
        this.user = new User_1.ClientUser(this, user);
        this.emit('ready', this);
    }
    /** @ignore */
    onWSReconnect() {
        this.emit('reconnect', this);
    }
    /** @ignore */
    onWSDisconnect() {
        this.emit('disconnect', this);
    }
    /** @ignore */
    onWSEvent(event, data) {
        (0, ws_2.handleWSEvent)(this, event, data);
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map