"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelWebhookManager = void 0;
const BaseManager_1 = require("../BaseManager");
const Webhook_1 = require("../../structures/Webhook");
const collection_1 = require("@discordjs/collection");
/**
 * The manager of webhooks that belong to a channel.
 * @example new ChannelWebhookManager(channel);
 */
class ChannelWebhookManager extends BaseManager_1.BaseManager {
    channel;
    /** @param channel The channel the webhooks belong to. */
    constructor(channel) {
        super(channel.client, channel.client.options.maxWebhookCache);
        this.channel = channel;
    }
    fetch(arg1, arg2) {
        if (typeof arg1 === 'string' || arg1 instanceof Webhook_1.Webhook)
            return this.fetchSingle(arg1, arg2);
        return this.fetchMany(arg1);
    }
    /** @ignore */
    async fetchSingle(webhook, options) {
        webhook = webhook instanceof Webhook_1.Webhook ? webhook.id : webhook;
        const cached = this.cache.get(webhook);
        if (cached && !options?.force)
            return cached;
        const raw = await this.client.api.webhooks.fetchSingle(this.channel.serverId, webhook);
        return new Webhook_1.Webhook(this.channel, raw, options?.cache);
    }
    /** @ignore */
    async fetchMany(options) {
        const raw = await this.client.api.webhooks.fetchMany(this.channel.serverId, this.channel.id);
        const webhooks = new collection_1.Collection();
        for (const data of raw) {
            const webhook = new Webhook_1.Webhook(this.channel, data, options?.cache);
            webhooks.set(webhook.id, webhook);
        }
        return webhooks;
    }
    /**
     * Create a webhook in the channel.
     * @param name The name of the webhook.
     * @returns The created webhook.
     * @example webhooks.create('My Webhook');
     */
    async create(name) {
        const raw = await this.client.api.webhooks.create(this.channel.serverId, this.channel.id, name);
        return new Webhook_1.Webhook(this.channel, raw);
    }
    /**
     * Edit a webhook in the channel.
     * @param webhook The webhook to edit.
     * @param name The name of the webhook.
     * @param channelId The ID of the channel to move the webhook to.
     * @returns The edited webhook.
     * @example webhooks.edit(webhook, 'My Webhook');
     */
    async edit(webhook, name, channelId) {
        webhook = webhook instanceof Webhook_1.Webhook ? webhook.id : webhook;
        const raw = await this.client.api.webhooks.edit(this.channel.serverId, webhook, name, channelId);
        return new Webhook_1.Webhook(this.channel, raw);
    }
    /**
     * Delete a webhook in the channel.
     * @param webhook The webhook to delete.
     * @example webhooks.delete(webhook);
     */
    delete(webhook) {
        webhook = webhook instanceof Webhook_1.Webhook ? webhook.id : webhook;
        return this.client.api.webhooks.delete(this.channel.serverId, webhook);
    }
}
exports.ChannelWebhookManager = ChannelWebhookManager;
//# sourceMappingURL=ChannelWebhookManager.js.map