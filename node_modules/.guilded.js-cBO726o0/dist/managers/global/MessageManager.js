"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMessageManager = void 0;
const Message_1 = require("../../structures/Message");
const CacheableStructManager_1 = require("./CacheableStructManager");
const collection_1 = require("@discordjs/collection");
const util_1 = require("../../util");
const structures_1 = require("../../structures");
/**
 * Manager for handling caching and interactions for Messages
 */
class GlobalMessageManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Whether or not messages should be cached.
     */
    get shouldCacheMessage() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMessages) !== false;
    }
    /**
     * Fetches multiple messages from a channel.
     * @param channelId The ID of the channel to fetch messages from.
     * @param options Additional options for the fetch.
     * @returns A promise that resolves with a collection of messages.
     */
    fetchMany(channelId, options) {
        return this.client.rest.router
            .getChannelMessages(channelId, options)
            .then((data) => {
            const messages = new collection_1.Collection();
            for (const message of data.messages) {
                const newMessage = new Message_1.Message(this.client, message);
                messages.set(newMessage.id, newMessage);
            }
            return messages;
        });
    }
    /**
     * Fetches a message from a channel.
     * @param channelId The ID of the channel to fetch the message from.
     * @param messageId The ID of the message to fetch.
     * @param force Whether or not to force the fetch.
     * @returns A promise that resolves with the requested message.
     */
    fetch(channelId, messageId, force) {
        if (!force) {
            const existingMessage = this.client.messages.cache.get(messageId);
            if (existingMessage)
                return Promise.resolve(existingMessage);
        }
        return this.client.rest.router
            .getChannelMessage(channelId, messageId)
            .then((data) => {
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /**
     * Sends a message to a channel.
     * @param channelId The ID of the channel to send the message to.
     * @param content The content of the message.
     * @returns A promise that resolves with the created message.
     */
    send(channelId, content) {
        return this.client.rest.router
            .createChannelMessage(channelId, (0, util_1.resolveContentToData)(content))
            .then((data) => {
            // This is in the case of which the WS gateway beats us to adding the message to the cache. If they haven't, then we do it ourselves.
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage;
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /**
     * Adds a reaction to a message.
     * @param channelId The ID of the channel containing the message.
     * @param contentId The ID of the message to add a reaction to.
     * @param emoteId The ID of the emote to add as a reaction.
     * @returns A promise that resolves to nothing when the reaction is added.
     */
    addReaction(channelId, contentId, emoteId) {
        return this.client.reactions.create(channelId, contentId, emoteId);
    }
    /**
     * Deletes a reaction from a message.
     * @param channelId The ID of the channel containing the message.
     * @param contentId The ID of the message to delete the reaction from.
     * @param emoteId The ID of the emote to delete as a reaction.
     * @returns A promise that resolves to nothing when the reaction is deleted.
     */
    deleteReaction(channelId, contentId, emoteId) {
        return this.client.reactions.delete(channelId, contentId, emoteId);
    }
    /**
     * Updates a message in a channel.
     * @param channelId The ID of the channel containing the message.
     * @param messageId The ID of the message to update.
     * @param content The new content of the message.
     * @returns A promise that resolves with the updated message.
     */
    update(channelId, messageId, content) {
        return this.client.rest.router
            .updateChannelMessage(channelId, messageId, (0, util_1.resolveContentToData)(content))
            .then((data) => {
            // This is in the case of which the WS gateway beats us to modifying the message in the cache. If they haven't, then we do it ourselves.
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage._update(data.message);
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Delete a channel message. */
    delete(channelId, messageId) {
        return this.client.rest.router
            .deleteChannelMessage(channelId, messageId)
            .then(() => void 0);
    }
    awaitMessages(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new structures_1.MessageCollector(this.client, Object.assign(Object.assign({}, options), { filter: (item) => {
                    var _a, _b;
                    if (item.channelId !== channelId)
                        return false;
                    return (_b = (_a = options.filter) === null || _a === void 0 ? void 0 : _a.call(options, item)) !== null && _b !== void 0 ? _b : true;
                } })).start();
        });
    }
}
exports.GlobalMessageManager = GlobalMessageManager;
//# sourceMappingURL=MessageManager.js.map