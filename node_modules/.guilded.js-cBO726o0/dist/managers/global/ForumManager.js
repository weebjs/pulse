"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalForumTopicManager = void 0;
const Forum_1 = require("../../structures/Forum");
const CacheableStructManager_1 = require("./CacheableStructManager");
const collection_1 = require("@discordjs/collection");
/**
 * Manager for interacting with forum topics at a global level.
 */
class GlobalForumTopicManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheForumTopic() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheForumTopics) !== false;
    }
    /**
     * Create a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param options The options for creating the forum topic.
     * @returns A Promise that resolves with the payload of the created forum topic.
     */
    create(channelId, options) {
        return this.client.rest.router
            .createForumTopic(channelId, options)
            .then((data) => new Forum_1.ForumTopic(this.client, data.forumTopic));
    }
    /**
     * Get all topics in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param options The options for filtering the forum topics.
     * @returns A Promise that resolves to a Collection of ForumTopics.
     */
    fetchMany(channelId, options) {
        return this.client.rest.router
            .getForumTopics(channelId, options)
            .then((data) => {
            const topics = new collection_1.Collection();
            for (const forumTopic of data.forumTopics) {
                const newTopic = new Forum_1.PartialForumTopic(this.client, forumTopic);
                topics.set(newTopic.id, newTopic);
            }
            return topics;
        });
    }
    /**
     * Get a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumThreadId The ID of the forum topic.
     * @returns a Promise that resolves to a ForumTopic.
     */
    fetch(channelId, forumTopicId) {
        return this.client.rest.router
            .getForumTopic(channelId, forumTopicId.toString())
            .then((data) => new Forum_1.ForumTopic(this.client, data.forumTopic));
    }
    /**
     * Update a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumThreadId The ID of the forum topic.
     * @param options The options for updating the forum topic.
     * @returns A Promise that resolves to the updated ForumTopic. If cached locally, it will modify that object.
     */
    update(channelId, forumThreadId, options) {
        return this.client.rest.router
            .updateForumTopic(channelId, forumThreadId, options)
            .then((data) => {
            // This is in the case of which the WS gateway beats us to modifying the topic in the cache. If they haven't, then we do it ourselves.
            const existingTopic = this.client.topics.cache.get(data.forumTopic.id);
            if (existingTopic)
                return existingTopic._update(data.forumTopic);
            const newTopic = new Forum_1.ForumTopic(this.client, data.forumTopic);
            this.client.topics.cache.set(newTopic.id, newTopic);
            return newTopic;
        });
    }
    /**
     * Delete a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumThreadId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    delete(channelId, forumThreadId) {
        return this.client.rest.router
            .deleteForumTopic(channelId, forumThreadId)
            .then(() => void 0);
    }
    /**
     * Pin a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumThreadId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    pin(channelId, forumThreadId) {
        return this.client.rest.router
            .pinForumTopic(channelId, forumThreadId)
            .then(() => void 0);
    }
    /**
     * Unpin a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumThreadId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    unpin(channelId, forumThreadId) {
        return this.client.rest.router
            .unpinForumTopic(channelId, forumThreadId)
            .then(() => void 0);
    }
    /**
     * Lock a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumThreadId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    lock(channelId, forumThreadId) {
        return this.client.rest.router
            .lockForumTopic(channelId, forumThreadId)
            .then(() => void 0);
    }
    /**
     * Unlock a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumThreadId The ID
     * @returns A Promise that resolves to nothing.
     */
    unlock(channelId, forumThreadId) {
        return this.client.rest.router
            .unlockForumTopic(channelId, forumThreadId)
            .then(() => void 0);
    }
}
exports.GlobalForumTopicManager = GlobalForumTopicManager;
//# sourceMappingURL=ForumManager.js.map