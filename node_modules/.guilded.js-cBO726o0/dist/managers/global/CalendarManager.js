"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalCalendarManager = void 0;
const collection_1 = require("@discordjs/collection");
const CacheableStructManager_1 = require("./CacheableStructManager");
const CalendarEvent_1 = require("../../structures/CalendarEvent");
/**
 * The manager is used to interact with calendars on a server.
 */
class GlobalCalendarManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheCalendar() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheCalendars) !== false;
    }
    get shouldCacheCalendarRsvps() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheCalendarsRsvps) !== false;
    }
    /**
     * Creates a calendar event.
     * @param channelId The ID of the channel in which to create the event.
     * @param options The options for the event.
     * @returns A promise that resolves with the created calendar event.
     */
    create(channelId, options) {
        return this.client.rest.router
            .createCalendarEvent(channelId, options)
            .then((data) => {
            return new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
        });
    }
    /**
     * Fetches a single calendar event.
     * @param channelId The ID of the channel in which to fetch the event.
     * @param calendarEventId The ID of the event to fetch.
     * @param force Whether or not to force a fetch instead of using a cached version.
     * @returns A promise that resolves with the fetched calendar event.
     */
    fetch(channelId, calendarEventId, force) {
        if (!force) {
            const existingCalendar = this.client.calendars.cache.get(calendarEventId);
            if (existingCalendar)
                return Promise.resolve(existingCalendar);
        }
        return this.client.rest.router
            .getCalendarEvent(channelId, calendarEventId)
            .then((data) => {
            const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
            if (this.shouldCacheCalendar)
                this.client.calendars.cache.set(newCalendar.id, newCalendar);
            return newCalendar;
        });
    }
    /**
     * Fetches multiple calendar events.
     * @param channelId The ID of the channel in which to fetch the events.
     * @param options The options for the fetch.
     * @returns A promise that resolves with a collection of the fetched calendar events.
     */
    fetchMany(channelId, options) {
        return this.client.rest.router
            .getCalendarEvents(channelId, options)
            .then((data) => {
            const calendarEvents = new collection_1.Collection();
            for (const calendarEvent of data.calendarEvents) {
                const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, calendarEvent);
                calendarEvents.set(newCalendar.id, newCalendar);
                if (this.shouldCacheCalendar)
                    this.client.calendars.cache.set(newCalendar.id, newCalendar);
            }
            return calendarEvents;
        });
    }
    /**
     * Updates a calendar event.
     * @param channelId The ID of the channel in which the event exists.
     * @param calendarEventId The ID of the event to update.
     * @param options The options for the update.
     * @returns A promise that resolves with the updated calendar event.
     */
    update(channelId, calendarEventId, options) {
        return this.client.rest.router
            .updateCalendarEvent(channelId, calendarEventId, options)
            .then((data) => {
            const existingCalendar = this.cache.get(calendarEventId);
            if (existingCalendar)
                return existingCalendar._update(data.calendarEvent);
            const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
            if (this.shouldCacheCalendar)
                this.cache.set(newCalendar.id, newCalendar);
            return newCalendar;
        });
    }
    /**
     * Delete a calendar event.
     * @param channelId - The ID of the channel where the calendar event is located.
     * @param calendarEventId - The ID of the calendar event to delete.
     * @returns A Promise that resolves with the deleted calendar event or `undefined` if the event was not cached.
     */
    delete(channelId, calendarEventId) {
        return this.client.rest.router
            .deleteCalendarEvent(channelId, calendarEventId)
            .then((data) => {
            const cachedCalendar = this.cache.get(calendarEventId);
            return cachedCalendar !== null && cachedCalendar !== void 0 ? cachedCalendar : void 0;
        });
    }
    /**
     * Get a single RSVP from a calendar event.
     * @param channelId - The ID of the channel where the calendar event is located.
     * @param calendarEventId - The ID of the calendar event to get the RSVP from.
     * @param userId - The ID of the user who made the RSVP.
     * @param force - Whether to force a request to the API instead of returning the cached RSVP.
     * @returns A Promise that resolves with the requested RSVP.
     */
    fetchRsvp(channelId, calendarEventId, userId, force) {
        var _a, _b;
        if (!force) {
            const existingRsvp = (_b = (_a = this.client.calendars.cache
                .get(calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.get(userId);
            if (existingRsvp)
                return Promise.resolve(existingRsvp);
        }
        return this.client.rest.router
            .getCalendarEventRsvp(channelId, calendarEventId, userId)
            .then((data) => {
            var _a, _b;
            const newRsvp = new CalendarEvent_1.CalendarEventRsvp(this.client, data.calendarEventRsvp);
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps)
                (_b = (_a = this.cache
                    .get(newRsvp.calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.set(newRsvp.userId, newRsvp);
            return newRsvp;
        });
    }
    /**
     * Fetch RSVPs for a calendar event.
     * @param channelId - The ID of the channel where the calendar event is located.
     * @param calendarEventId - The ID of the calendar event to fetch RSVPs for.
     * @returns A Promise that resolves with a collection of RSVPs.
     */
    fetchManyRsvps(channelId, calendarEventId) {
        return this.client.rest.router
            .getCalendarEventRsvps(channelId, calendarEventId)
            .then((data) => {
            var _a;
            const rsvpEvents = new collection_1.Collection();
            for (const rsvpEvent of data.calendarEventRsvps) {
                if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps) {
                    const cachedCalendar = this.cache.get(calendarEventId);
                    (_a = cachedCalendar === null || cachedCalendar === void 0 ? void 0 : cachedCalendar.rsvps) === null || _a === void 0 ? void 0 : _a.set(rsvpEvent.userId, new CalendarEvent_1.CalendarEventRsvp(this.client, rsvpEvent));
                }
                rsvpEvents.set(rsvpEvent.userId, new CalendarEvent_1.CalendarEventRsvp(this.client, rsvpEvent));
            }
            return rsvpEvents;
        });
    }
    /**
     * Creates or updates an RSVP for a calendar event.
     * @param channelId The ID of the channel.
     * @param calendarEventId The ID of the calendar event.
     * @param userId The ID of the user.
     * @param options The options for updating the RSVP.
     * @returns A promise that resolves with the updated or created RSVP.
     */
    updateRsvp(channelId, calendarEventId, userId, options) {
        return this.client.rest.router
            .updateCalendarEventRvsp(channelId, calendarEventId, userId, options)
            .then((data) => {
            var _a, _b, _c, _d;
            const existingRsvp = (_b = (_a = this.cache
                .get(calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.get(userId);
            if (existingRsvp)
                return existingRsvp === null || existingRsvp === void 0 ? void 0 : existingRsvp._update(data.calendarEventRsvp);
            const newRsvp = new CalendarEvent_1.CalendarEventRsvp(this.client, data.calendarEventRsvp);
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps)
                (_d = (_c = this.cache.get(calendarEventId)) === null || _c === void 0 ? void 0 : _c.rsvps) === null || _d === void 0 ? void 0 : _d.set(userId, newRsvp);
            return newRsvp;
        });
    }
    /**
     * Deletes an RSVP for a calendar event.
     * @param channelId The ID of the channel.
     * @param calendarEventId The ID of the calendar event.
     * @param userId The ID of the user.
     * @returns A promise that resolves with the deleted RSVP or void if it was not cached.
     */
    deleteRsvp(channelId, calendarEventId, userId) {
        return this.client.rest.router
            .deleteCalendarEventRvsp(channelId, calendarEventId, userId)
            .then((data) => {
            var _a;
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps) {
                const cachedCalendar = this.cache.get(calendarEventId);
                const rsvp = (_a = cachedCalendar === null || cachedCalendar === void 0 ? void 0 : cachedCalendar.rsvps) === null || _a === void 0 ? void 0 : _a.get(userId);
                return rsvp !== null && rsvp !== void 0 ? rsvp : void 0;
            }
            return void 0;
        });
    }
}
exports.GlobalCalendarManager = GlobalCalendarManager;
//# sourceMappingURL=CalendarManager.js.map