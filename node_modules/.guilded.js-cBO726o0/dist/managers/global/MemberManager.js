"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMemberManager = void 0;
const structures_1 = require("../../structures");
const Member_1 = require("../../structures/Member");
const CacheableStructManager_1 = require("./CacheableStructManager");
const collection_1 = require("@discordjs/collection");
const util_1 = require("../../util");
/**
 * A class representing a manager for Discord server members.
 * @extends CacheableStructManager.
 */
class GlobalMemberManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Fetches a member from a server.
     * @param serverId The ID of the server to fetch the member from.
     * @param memberId The ID of the member to fetch.
     * @param force Whether to force a fetch from the API.
     * @returns A Promise that resolves with the fetched member.
     */
    fetch(serverId, memberId, force) {
        const memberKey = (0, util_1.buildMemberKey)(serverId, memberId);
        if (!force) {
            const existingMember = this.client.members.cache.get(memberKey);
            if (existingMember)
                return Promise.resolve(existingMember);
        }
        return this.client.rest.router
            .getMember(serverId, memberId)
            .then((data) => {
            const newMember = new Member_1.Member(this.client, Object.assign(Object.assign({}, data.member), { serverId, id: data.member.user.id }));
            this.client.users.cache.set(data.member.user.id, new structures_1.User(this.client, data.member.user));
            this.client.members.cache.set(memberKey, newMember);
            return newMember;
        });
    }
    /**
     * Fetches all members from a server. Returned objects are partial members.
     * @param serverId The ID of the server to fetch members from.
     * @returns A Promise that resolves with a collection of partial members.
     */
    fetchMany(serverId) {
        return this.client.rest.router.getMembers(serverId).then((data) => {
            const members = new collection_1.Collection();
            for (const member of data.members) {
                const newMember = new Member_1.PartialMember(this.client, Object.assign({ serverId, id: member.user.id }, member));
                members.set(newMember.id, newMember);
            }
            return members;
        });
    }
    /**
     * Kicks a member from a server.
     * @param serverId The ID of the server to kick the member from.
     * @param memberId The ID of the member to kick.
     * @returns A Promise that resolves with the kicked member, or null if the member was not cached.
     */
    kick(serverId, memberId) {
        return this.client.rest.router
            .kickMember(serverId, memberId)
            .then((_) => {
            var _a;
            return (_a = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, memberId))) !== null && _a !== void 0 ? _a : null;
        });
    }
    /**
     * Bans a member from a server.
     * @param serverId The ID of the server to ban the member from.
     * @param userId The ID of the user to ban.
     * @returns A Promise that resolves with the banned member, or null if the member was not cached.
     */
    ban(serverId, userId) {
        return this.client.bans.ban(serverId, userId);
    }
    /**
     * Gets a list of the roles assigned to a member using the ID of the member.
     * @param serverId The ID of the server to get the member roles from.
     * @param memberId The ID of the member to get the roles for.
     * @returns A Promise that resolves with an array of role IDs.
     */
    getRoles(serverId, memberId) {
        return this.client.rest.router
            .getMemberRoles(serverId, memberId)
            .then((data) => data.roleIds);
    }
    /**
     * Updates a member's nickname. Returns the new name.
     * @param serverId The ID of the server to update the member nickname for.
     * @param memberId The ID of the member to update the nickname for.
     * @param newNickname The new nickname for the member.
     * @returns A Promise that resolves with the updated nickname.
     */
    updateNickname(serverId, memberId, newNickname) {
        return this.client.rest.router
            .updateMemberNickname(serverId, memberId, newNickname)
            .then((data) => data.nickname);
    }
    /**
     * Deletes a member's nickname.
     * @param serverId The ID of the server to delete the member nickname from.
     * @param memberId The ID of the member to delete the nickname for.
     * @returns A Promise that resolves with no value upon completion.
     */
    resetNickname(serverId, memberId) {
        return this.client.rest.router
            .deleteMemberNickname(serverId, memberId)
            .then(() => void 0);
    }
    /**
     * Awards XP to a member.
     * @param serverId The ID of the server to award XP on.
     * @param memberId The ID of the member to award XP to.
     * @param amount The amount of XP to award.
     * @returns A Promise that resolves with the member's new total XP.
     */
    giveXP(serverId, memberId, amount) {
        return this.client.rest.router
            .awardMemberXP(serverId, memberId, amount)
            .then((data) => data.total);
    }
    /**
     * Fetch a member's social links
     * @param serverId The ID of the server to award XP on.
     * @param memberId The ID of the member to award XP to.
     * @param type The type of social link to fetch
     * @returns A Promise that resolves with the member's social link.
     */
    fetchSocialLinks(serverId, memberId, type) {
        return this.client.rest.router
            .getMemberSocialLinks(serverId, memberId, type)
            .then((data) => data.socialLink);
    }
}
exports.GlobalMemberManager = GlobalMemberManager;
//# sourceMappingURL=MemberManager.js.map