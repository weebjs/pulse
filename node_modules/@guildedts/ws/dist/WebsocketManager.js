"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketManager = void 0;
const ws_1 = __importDefault(require("ws"));
const events_1 = __importDefault(require("events"));
const guilded_api_typings_1 = require("guilded-api-typings");
const { version } = require('../package.json');
/**
 * The Websocket manager for the Guilded API.
 * @example new WebsocketManager({ version: 1, token: 'token' });
 */
class WebsocketManager extends events_1.default {
    options;
    /** The auth token for the websocket. */
    token;
    /** The version of the Websocket API. */
    version;
    /** The proxy URL of the Websocket API. */
    proxyUrl;
    /** The websocket. */
    socket;
    /** The date the websocket is ready. */
    readyAt;
    /** The ping of the websocket connection. */
    ping;
    /** The date the websocket was pinged. */
    pingedAt;
    /** The anount of times the websocket has been reconnected. */
    reconnects = 0;
    /** The last message ID. */
    lastMessageId;
    /** @param options The options for the Websocket manager. */
    constructor(options) {
        super();
        this.options = options;
        this.token = options.token;
        this.proxyUrl = options.proxyUrl;
        if (!this.proxyUrl)
            this.version = options.version;
    }
    /** Whether the websocket is ready. */
    get isReady() {
        return !!this.readyAt;
    }
    /** The timestamp of when the websocket is ready. */
    get readyTimestamp() {
        return this.readyAt?.getTime();
    }
    /** The timestamp the websocket was pinged. */
    get pingedTimestamp() {
        return this.pingedAt?.getTime();
    }
    /** How long the websocket has been connected. */
    get uptime() {
        return this.isReady ? Date.now() - this.readyTimestamp : undefined;
    }
    /** The URL of the Websocket. */
    get url() {
        return this.proxyUrl ? this.proxyUrl : `wss://www.guilded.gg/websocket/v${this.version}`;
    }
    /**
     * Connect to the Websocket API.
     * @param token The auth token.
     * @returns The Websocket manager.
     * @example ws.connect('token');
     */
    connect(token = this.token) {
        this.token = token;
        this.socket = new ws_1.default(this.url, {
            headers: {
                Authorization: `Bearer ${this.token}`,
                'User-Agent': `@guildedts/ws@${version} Node.JS@${process.versions.node}`,
                'guilded-last-message-id': this.lastMessageId ?? '',
            },
        });
        this.socket.on('close', this.onSocketDisconnect.bind(this));
        this.socket.on('message', (raw) => {
            const data = JSON.parse(raw.toString());
            this.emit('raw', data);
            this.onSocketMessage(data);
        });
        this.socket.on('ping', this.onSocketPing.bind(this));
        this.socket.on('pong', this.onSocketPong.bind(this));
        return this;
    }
    /**
     * Disconnect from the Websocket API.
     * @returns The websocket manager.
     * @example ws.disconnect();
     */
    disconnect() {
        if (!this.socket || !this.socket.OPEN)
            throw new Error('Websocket is not connected.');
        this.socket.terminate();
        return this;
    }
    /** @ignore */
    onSocketDisconnect() {
        this.socket = undefined;
        this.readyAt = undefined;
        if (!this.options.reconnect || this.reconnects >= (this.options.maxReconnects ?? Infinity))
            return this.emit('disconnect', this);
        this.reconnects++;
        this.connect();
        this.emit('reconnect', this);
    }
    /** @ignore */
    onSocketMessage({ op, t, d, s }) {
        if (s)
            this.lastMessageId = s;
        switch (op) {
            case guilded_api_typings_1.WSOpCode.Event:
                this.emit('event', t, d);
                break;
            case guilded_api_typings_1.WSOpCode.Ready:
                this.socket?.emit('ping');
                this.readyAt = new Date();
                this.emit('ready', d.user);
                break;
            case guilded_api_typings_1.WSOpCode.Resume:
                delete this.lastMessageId;
                break;
        }
    }
    /** @ignore */
    onSocketPing() {
        this.pingedAt = new Date();
        this.socket.ping();
    }
    /** @ignore */
    onSocketPong() {
        this.ping = Date.now() - this.pingedTimestamp;
    }
}
exports.WebsocketManager = WebsocketManager;
//# sourceMappingURL=WebsocketManager.js.map